\section{Python}
\subsection{Python's whys \& hows}
\subsubsection{What is Python}
\paragraph{Python is a general-purpose high-level programming language}
\begin{itemize}
	\item it pushes code readability and productivity;
	\item it best fits the role of scripting language.
	\end{itemize}
\paragraph{Python support multiple programming paradigms}
\begin{itemize}
	\item imperative (function, state, ...);
	\item object-oriented/based (objects, methods, inheritance, ...);
	\item functional (lambda abstractions, generators, dynamic typing, ...).
\end{itemize}
\paragraph{Python is}
\begin{itemize}
	\item interpreted, dynamic typed and object-based;
	\item open-source.
\end{itemize}
\subsubsection{How to use Python}	
\paragraph{We are condidering Python 3+}
\begin{itemize}
	\item version > 3 is incompatible with previus version;
	\item version 2.7 is the current version.
\end{itemize}
\paragraph{A python program can be:}
\begin{itemize}
	\item edited in the python shell and executed step-by-step by the shell;
	\item edited and run through the iterpreter.
\end{itemize}
\subsection{Overview of the Basic Concepts}	
\subsubsection{Our first Python program}
\hrule
\begin{lstlisting}[language=Python, caption=humanize.py]
SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], 
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}
def approximate_size(size, a_kilobyte_is_1024_bytes=True):
	''' Convert a file size to human-readable form. '''
	if size < 0:
		raise ValueError('number must be non-negative')
	multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
	for suffix in SUFFIX[multiple]:
		size /= multiple
		if size < multiple:
			return '{0:.1f} {1}'.format(size, suffix)
		raise ValueError('number too large')
				
if __name__ == '__main__':
	print(approximate_size(1000000000000, False))
	print(approximate_size(1000000000000))
\end{lstlisting}
\hrule	
\subsubsection{Declaring function}	
\paragraph{Python has function}
\begin{itemize}
	\item no header files à la C/C++;
	\item no interface/implementation à la Java.
\end{itemize}			
\hrule
\begin{lstlisting}[language=Python]
def approximate_size(size, a_kilobyte_is_1024_bytes=True):
\end{lstlisting}	
\begin{enumerate}
	\item \textbf{def}: function definition keyword;
	\item \textbf{approximate\_size}: function name;
	\item \textbf{a\_kilobyte\_is\_1024\_bytes}: comma separate argument list;
	\item \textbf{=True}: default value.
\end{enumerate}
\hrule		
\paragraph{Python has function}
\begin{itemize}
	\item no return type, it always return a value (\textbf{None} as a default); 
	\item no parameter types, the interpreter figures out the parameter type.
\end{itemize}	
\subsubsection{Calling Functions}
\paragraph{Look at the bottom of the \textit{humanize.py} program}
\hrule
\begin{lstlisting}[language=Python]
if __name__ == '__main__':
	print(approximate_size(1000000000000, False))
	print(approximate_size(1000000000000))
\end{lstlisting}
\begin{enumerate}
	\item[2] in this call to \textbf{approximate\_size()}, the \textbf{a\_kilobyte\_is\_1024\_bytes} parameter will be \textbf{False} since you explicitly pass it to the function;
	\item[3] in this row we call  \textbf{approximate\_size()} with only a value, the parameter \textbf{a\_kilobyte\_is\_1024\_bytes} will be \textbf{True} as defined in the function declaration.
\end{enumerate}
\hrule
\paragraph{Value can be passed by name as in}:
\hrule
\begin{lstlisting}[language=Python]
def approximate_size(a_kilobyte_is_1024_bytes=True, size=1000000000000)
\end{lstlisting}	
\hrule
\paragraph{Parameters' order is not relevant}
\subsubsection{Writing readable code}
\paragraph{Documentation Strings}
A python function can be documented by a documentation string (docstring for short).
\begin{center}
	\textit{''' Convert a file size to human-readable form.  '''}
\end{center}
\paragraph{Triple quotes delimit a single multi-string}
\begin{itemize}
	\item if it immediatly follows the function's declaration it is the doc-string associated to the function;
	\item docstrings can be retrieved at run-time (they are attributes).
\end{itemize}
\paragraph{Case-Sensitive}
All names in Python are case-sensitive
\subsubsection{Everything is an object}
\paragraph{Everything in Python is an object, functions included}
\begin{itemize}
	\item \textbf{import} can be used to load python programs in the system as modules;
	\item the dot-notation gives access to the the public functionality of the imported modules;
	\item the dot-notation can be used to access the attributes (e.g., the \textbf{\_\_doc\_\_})
	\item \textbf{humanize\.approximate\_size.\_\_doc\_\_} gives access to the docstring of the \textbf{approximate\_size()} function; the docstring is stored as an attribute.
\end{itemize}
\subsubsection{Everything is an object (Cont'd)}
\paragraph{In python is an object, better, is a \textbf{first-calss object}}
\begin{itemize}
	\item everything can be assigned to a variable or passed as an argument
\end{itemize}
\hrule
\begin{lstlisting}[language=Python]
h1 = humanize.approximate_size(9128)
h2 = humanize.approximate_size
\end{lstlisting}	
\begin{itemize}
	\item \textbf{h1} contains the string calculated by \textbf{approximate\_size(9128};
	\item \textbf{h2} contains the "function" object \textbf{approximate\_size()}, the result is not calculated yet;
	\item to simplify the concept: \textbf{h2} can be considered as a new name of (alias to) \textbf{approximate\_size}.
\end{itemize}
\hrule
\subsubsection{Indenting code}
\paragraph{No explicit block delimiters}
\begin{itemize}
	\item the only delimiter is a column (':') and the code indentation;
	\item code blocks (e.g., functions, if statements, loops, ...) are defined by their indentation;
	\item white spaces and tabs are relevant: use them consistently;
	\item indentation is checked by the compiler.
\end{itemize}
\subsubsection{Exceptions}
\paragraph{Exceptions are Anomaly Situations}
\begin{itemize}
	\item C encourages the use of return codes which you check;
	\item Python encourages the use of exceptions which you handles.
\end{itemize}
\paragraph{Raising Exceptions}
\begin{itemize}
	\item the \textbf{raise} statement is used to rise an exception as in:
\begin{lstlisting}[language=Python]
raise ValueError('number must be non-negative')
\end{lstlisting}
	\item syntax recalls function calls: \textbf{raise} statement followed by an exception name with an optional argument;
	\item exceptions are relized by classes.
\end{itemize}
\paragraph{No need to list the exceptions in the function declaration handling Exceptions}
\begin{itemize}
	\item an exception is handled by a \textbf{try} ... \textbf{except} block.
\hrule
\begin{lstlisting}[language=Python]
try:
	from lxml import etree
except ImportError:
	import xml.etree.ElementTree as etree
\end{lstlisting}
\hrule
\end{itemize}
\subsubsection{Running scripts}
\paragraph{Look again, at the bottom of the \textit{humanize.py} program}:
\hrule
\begin{lstlisting}
if __name__ == '__main__':
	print(approximate_size(1000000000000, False))
	print(approximate_size(1000000000000))
\end{lstlisting}
\hrule
\paragraph{Modules are Objects}
\begin{itemize}
	\item they have a built-in attribute \textbf{\_\_name\_\_}
\end{itemize}
\paragraph{The value of \textbf{\_\_name\_\_} depends on how you call it}
\begin{itemize}
	\item if imported it contains the name of the file without path and extension.
\end{itemize}